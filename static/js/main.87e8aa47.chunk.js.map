{"version":3,"sources":["varintUtils.js","protobufDecoder.js","protobufPartDecoder.js","ProtobufPart.js","ProtobufDisplay.js","App.js","index.js","hexUtils.js"],"names":["BIGINT_1","JSBI","BigInt","BIGINT_2","BufferReader","buffer","this","offset","result","res","shift","byte","length","RangeError","multiplier","exponentiate","thisByteValue","multiply","add","value","decodeVarint","checkByte","slice","backupOffset","leftBytes","readInt32BE","bytesAvailable","Error","savedOffset","TYPES","decodeProto","reader","parts","trySkipGrpcHeader","checkpoint","indexType","parseInt","readVarInt","toString","type","index","readBuffer","push","err","resetToCheckpoint","leftOver","decodeFixed64","floatValue","readDoubleLE","uintValue","bufferLeToBeHex","intValue","greaterThan","maxLong","subtract","longForComplement","twoComplements","decodeVarintParts","intVal","n","signedIntVal","equal","bitwiseAnd","divide","ProtobufVarintPart","props","map","d","i","key","ProtobufStringPart","decoded","ProtobufFixed64Part","ProtobufFixed32Part","readFloatLE","readInt32LE","readUInt32LE","decodeFixed32","ProtobufPart","part","stringType","typeToString","Table","Row","Cell","getProtobufPart","ProtobufDisplay","bufferToPrettyHex","dangerouslySetInnerHTML","__html","celled","Header","HeaderCell","Body","App","useState","hex","setHex","hexBuffer","setHexBuffer","as","Container","Form","Group","TextArea","placeholder","onChange","e","target","Button","primary","fluid","onClick","parseInput","Divider","href","ReactDOM","render","document","getElementById","input","normalizedInput","replace","normalizedHexInput","toLowerCase","string","char","isHex","Buffer","from","output","v"],"mappings":"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","file":"static/js/main.87e8aa47.chunk.js","sourcesContent":["import JSBI from \"jsbi\";\n\nconst BIGINT_1 = JSBI.BigInt(1);\nconst BIGINT_2 = JSBI.BigInt(2);\n\nexport function interpretAsSignedType(n) {\n  // see https://github.com/protocolbuffers/protobuf/blob/master/src/google/protobuf/wire_format_lite.h#L857-L876\n  // however, this is a simpler equivalent formula\n  const isEven = JSBI.equal(JSBI.bitwiseAnd(n, JSBI.BigInt(1)), JSBI.BigInt(0));\n  if (isEven) {\n    return JSBI.divide(n, BIGINT_2);\n  } else {\n    return JSBI.multiply(\n      JSBI.BigInt(-1),\n      JSBI.divide(JSBI.add(n, BIGINT_1), BIGINT_2)\n    );\n  }\n}\n\nexport function decodeVarint(buffer, offset) {\n  let res = JSBI.BigInt(0);\n  let shift = 0;\n  let byte = 0;\n\n  do {\n    if (offset >= buffer.length) {\n      throw new RangeError(\"Index out of bound decoding varint\");\n    }\n\n    byte = buffer[offset++];\n\n    const multiplier = JSBI.exponentiate(BIGINT_2, JSBI.BigInt(shift));\n    const thisByteValue = JSBI.multiply(JSBI.BigInt(byte & 0x7f), multiplier);\n    shift += 7;\n    res = JSBI.add(res, thisByteValue);\n  } while (byte >= 0x80);\n\n  return {\n    value: res,\n    length: shift / 7\n  };\n}\n","import { decodeVarint } from \"./varintUtils\";\n\nclass BufferReader {\n  constructor(buffer) {\n    this.buffer = buffer;\n    this.offset = 0;\n  }\n\n  readVarInt() {\n    const result = decodeVarint(this.buffer, this.offset);\n    this.offset += result.length;\n\n    return result.value;\n  }\n\n  readBuffer(length) {\n    this.checkByte(length);\n    const result = this.buffer.slice(this.offset, this.offset + length);\n    this.offset += length;\n\n    return result;\n  }\n\n  // gRPC has some additional header - remove it\n  trySkipGrpcHeader() {\n    const backupOffset = this.offset;\n\n    if (this.buffer[this.offset] === 0 && this.leftBytes() >= 5) {\n      this.offset++;\n      const length = this.buffer.readInt32BE(this.offset);\n      this.offset += 4;\n\n      if (length > this.leftBytes()) {\n        // Something is wrong, revert\n        this.offset = backupOffset;\n      }\n    }\n  }\n\n  leftBytes() {\n    return this.buffer.length - this.offset;\n  }\n\n  checkByte(length) {\n    const bytesAvailable = this.leftBytes();\n    if (length > bytesAvailable) {\n      throw new Error(\n        \"Not enough bytes left. Requested: \" +\n          length +\n          \" left: \" +\n          bytesAvailable\n      );\n    }\n  }\n\n  checkpoint() {\n    this.savedOffset = this.offset;\n  }\n\n  resetToCheckpoint() {\n    this.offset = this.savedOffset;\n  }\n}\n\nexport const TYPES = {\n  VARINT: 0,\n  FIXED64: 1,\n  STRING: 2,\n  FIXED32: 5\n};\n\nexport function decodeProto(buffer) {\n  const reader = new BufferReader(buffer);\n  const parts = [];\n\n  reader.trySkipGrpcHeader();\n\n  try {\n    while (reader.leftBytes() > 0) {\n      reader.checkpoint();\n\n      const indexType = parseInt(reader.readVarInt().toString());\n      const type = indexType & 0b111;\n      const index = indexType >> 3;\n\n      let value;\n      if (type === TYPES.VARINT) {\n        value = reader.readVarInt().toString();\n      } else if (type === TYPES.STRING) {\n        const length = parseInt(reader.readVarInt().toString());\n        value = reader.readBuffer(length);\n      } else if (type === TYPES.FIXED32) {\n        value = reader.readBuffer(4);\n      } else if (type === TYPES.FIXED64) {\n        value = reader.readBuffer(8);\n      } else {\n        throw new Error(\"Unknown type: \" + type);\n      }\n\n      parts.push({\n        index,\n        type,\n        value\n      });\n    }\n  } catch (err) {\n    reader.resetToCheckpoint();\n  }\n\n  return {\n    parts,\n    leftOver: reader.readBuffer(reader.leftBytes())\n  };\n}\n\nexport function typeToString(type) {\n  switch (type) {\n    case TYPES.VARINT:\n      return \"varint\";\n    case TYPES.STRING:\n      return \"string\";\n    case TYPES.FIXED32:\n      return \"fixed32\";\n    case TYPES.FIXED64:\n      return \"fixed64\";\n    default:\n      return \"unknown\";\n  }\n}\n","import JSBI from \"jsbi\";\nimport { bufferLeToBeHex } from \"./hexUtils\";\nimport { interpretAsSignedType } from \"./varintUtils\";\n\nexport function decodeFixed32(value) {\n  const floatValue = value.readFloatLE(0);\n  const intValue = value.readInt32LE(0);\n  const uintValue = value.readUInt32LE(0);\n\n  const result = [];\n\n  result.push({ type: \"Int\", value: intValue });\n\n  if (intValue !== uintValue) {\n    result.push({ type: \"Unsigned Int\", value: uintValue });\n  }\n\n  result.push({ type: \"Float\", value: floatValue });\n\n  return result;\n}\n\nexport function decodeFixed64(value) {\n  const floatValue = value.readDoubleLE(0);\n  const uintValue = JSBI.BigInt(\"0x\" + bufferLeToBeHex(value));\n  const intValue = twoComplements(uintValue);\n\n  const result = [];\n\n  result.push({ type: \"Int\", value: intValue.toString() });\n\n  if (intValue !== uintValue) {\n    result.push({ type: \"Unsigned Int\", value: uintValue.toString() });\n  }\n\n  result.push({ type: \"Double\", value: floatValue });\n\n  return result;\n}\n\nexport function decodeVarintParts(value) {\n  const result = [];\n  const intVal = JSBI.BigInt(value);\n  result.push({ type: \"Int\", value: intVal.toString() });\n\n  const signedIntVal = interpretAsSignedType(intVal);\n  if (signedIntVal !== intVal) {\n    result.push({ type: \"Signed Int\", value: signedIntVal.toString() });\n  }\n  return result;\n}\n\nconst maxLong = JSBI.BigInt(\"0x7fffffffffffffff\");\nconst longForComplement = JSBI.BigInt(\"0x10000000000000000\");\n\nfunction twoComplements(uintValue) {\n  if (JSBI.greaterThan(uintValue, maxLong)) {\n    return JSBI.subtract(uintValue, longForComplement);\n  } else {\n    return uintValue;\n  }\n}\n","import React from \"react\";\nimport { Table } from \"semantic-ui-react\";\nimport { decodeProto, TYPES, typeToString } from \"./protobufDecoder\";\nimport {\n  decodeFixed32,\n  decodeFixed64,\n  decodeVarintParts\n} from \"./protobufPartDecoder\";\nimport ProtobufDisplay from \"./ProtobufDisplay\";\n\nfunction ProtobufVarintPart(props) {\n  const { value } = props;\n  const decoded = decodeVarintParts(value);\n\n  return decoded.map((d, i) => (\n    <span key={i}>\n      As {d.type}: {d.value}\n      <br />\n    </span>\n  ));\n}\n\nfunction ProtobufStringPart(props) {\n  const { value } = props;\n\n  // TODO: Support repeated field\n\n  const decoded = decodeProto(value);\n  if (value.length > 0 && decoded.leftOver.length === 0) {\n    return <ProtobufDisplay value={decoded} />;\n  } else {\n    return value.toString();\n  }\n}\n\nfunction ProtobufFixed64Part(props) {\n  const { value } = props;\n  const decoded = decodeFixed64(value);\n\n  return decoded.map((d, i) => (\n    <span key={i}>\n      As {d.type}: {d.value}\n      <br />\n    </span>\n  ));\n}\n\nfunction ProtobufFixed32Part(props) {\n  const { value } = props;\n  const decoded = decodeFixed32(value);\n\n  return decoded.map(d => (\n    <span>\n      As {d.type}: {d.value}\n      <br />\n    </span>\n  ));\n}\n\nfunction getProtobufPart(part) {\n  switch (part.type) {\n    case TYPES.VARINT:\n      return <ProtobufVarintPart value={part.value} />;\n    case TYPES.STRING:\n      return <ProtobufStringPart value={part.value} />;\n    case TYPES.FIXED64:\n      return <ProtobufFixed64Part value={part.value} />;\n    case TYPES.FIXED32:\n      return <ProtobufFixed32Part value={part.value} />;\n    default:\n      return \"Unknown type\";\n  }\n}\n\nfunction ProtobufPart(props) {\n  const { part } = props;\n\n  const stringType = typeToString(part.type);\n\n  return (\n    <Table.Row>\n      <Table.Cell>{part.index}</Table.Cell>\n      <Table.Cell>{stringType}</Table.Cell>\n      <Table.Cell>{getProtobufPart(part)}</Table.Cell>\n    </Table.Row>\n  );\n}\n\nexport default ProtobufPart;\n","import React, { Fragment } from \"react\";\nimport ProtobufPart from \"./ProtobufPart\";\nimport { Table } from \"semantic-ui-react\";\nimport { bufferToPrettyHex } from \"./hexUtils\";\n\nfunction ProtobufDisplay(props) {\n  const { value } = props;\n\n  const parts = value.parts.map((part, i) => {\n    return <ProtobufPart key={i} part={part} />;\n  });\n\n  const leftOver = value.leftOver.length ? (\n    <p>Left over bytes: {bufferToPrettyHex(value.leftOver)}</p>\n  ) : null;\n\n  return (\n    <Fragment>\n      <style\n        dangerouslySetInnerHTML={{\n          __html: `td { white-space: pre-wrap; word-break: break-word }`\n        }}\n      />\n      <Table celled>\n        <Table.Header>\n          <Table.Row>\n            <Table.HeaderCell>Field Number</Table.HeaderCell>\n            <Table.HeaderCell>Type</Table.HeaderCell>\n            <Table.HeaderCell>Content</Table.HeaderCell>\n          </Table.Row>\n        </Table.Header>\n\n        <Table.Body>{parts}</Table.Body>\n      </Table>\n      {leftOver}\n    </Fragment>\n  );\n}\n\nexport default ProtobufDisplay;\n","import React, { Fragment, useState } from \"react\";\nimport { Container, Divider, Form, Header, TextArea } from \"semantic-ui-react\";\nimport { parseInput, bufferToPrettyHex } from \"./hexUtils\";\nimport \"./App.css\";\nimport ProtobufDisplay from \"./ProtobufDisplay\";\nimport { decodeProto } from \"./protobufDecoder\";\n\nfunction App() {\n  const [hex, setHex] = useState(\"\");\n  const [hexBuffer, setHexBuffer] = useState(\"\");\n\n  const onHexChanged = e => {\n    setHex(e.target.value);\n  };\n\n  const onSubmit = () => {\n    const buffer = parseInput(hex);\n\n    // Set pretty hex back to UI\n    setHex(bufferToPrettyHex(buffer));\n\n    // Set to hexBuffer which will be sent to render\n    setHexBuffer(buffer);\n  };\n\n  const result = hexBuffer ? (\n    <Fragment>\n      <Header as=\"h2\">Result</Header>\n      <ProtobufDisplay value={decodeProto(hexBuffer)} />\n    </Fragment>\n  ) : null;\n\n  return (\n    <Container>\n      <Header as=\"h1\">Protobuf Decoder</Header>\n      <p>\n        Tool to decode Protobuf without having the original .proto files. All\n        decoding is done locally via JavaScript.\n      </p>\n      <Form>\n        <Form.Group>\n          <TextArea\n            placeholder=\"Paste Protobuf or gRPC request as hex or base64\"\n            onChange={onHexChanged}\n            value={hex}\n          />\n        </Form.Group>\n        <Form.Button primary fluid onClick={onSubmit}>\n          Decode\n        </Form.Button>\n      </Form>\n      {result}\n      <Divider />\n      <p>\n        Made by pawitp. Contribute on{\" \"}\n        <a href=\"https://github.com/pawitp/protobuf-decoder\">GitHub</a>.\n      </p>\n    </Container>\n  );\n}\n\nexport default App;\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport App from \"./App\";\nimport \"semantic-ui-css/semantic.min.css\";\n\nReactDOM.render(<App />, document.getElementById(\"root\"));\n","export function parseInput(input) {\n  const normalizedInput = input.replace(/\\s/g, \"\");\n  const normalizedHexInput = normalizedInput.replace(/0x/g, \"\").toLowerCase();\n  if (isHex(normalizedHexInput)) {\n    return Buffer.from(normalizedHexInput, \"hex\");\n  } else {\n    return Buffer.from(normalizedInput, \"base64\");\n  }\n}\n\nexport function isHex(string) {\n  let result = true;\n  for (const char of string) {\n    if (!((char >= \"a\" && char <= \"f\") || (char >= \"0\" && char <= \"9\"))) {\n      result = false;\n    }\n  }\n  return result;\n}\n\nexport function bufferToPrettyHex(buffer) {\n  let output = \"\";\n  for (const v of buffer) {\n    if (output !== \"\") {\n      output += \" \";\n    }\n\n    const hex = v.toString(16);\n    if (hex.length === 1) {\n      output += \"0\" + hex;\n    } else {\n      output += hex;\n    }\n  }\n  return output;\n}\n\nexport function bufferLeToBeHex(buffer) {\n  let output = \"\";\n  for (const v of buffer) {\n    const hex = v.toString(16);\n    if (hex.length === 1) {\n      output = \"0\" + hex + output;\n    } else {\n      output = hex + output;\n    }\n  }\n  return output;\n}\n"],"sourceRoot":""}